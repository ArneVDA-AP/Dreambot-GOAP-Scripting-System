Project: DreamBot GOAP Scripting System - Tutorial Island MVP
Version: 0.2 (End of Phase 4 Implementation, Pre-Testing)
Date: 2025-04-06
1. High-Level Summary
This project implements a modular scripting framework for DreamBot (targeting Old School RuneScape - OSRS) using a Goal-Oriented Action Planning (GOAP) architecture. The primary goal of this initial Minimum Viable Product (MVP) phase is to validate the GOAP approach by fully automating the OSRS Tutorial Island sequence.
The system is designed with extensibility, maintainability, and human-like behavior simulation in mind. It leverages the DreamBot API for game state observation and action execution. Core logic from a previous TaskNode-based AIO script (specifically the Utils package) has been integrated.
Key Goals Achieved (Up to End of Phase 4 Implementation):
Core GOAP data structures (WorldState, Goal, Plan, Action, ActionResult, WorldStateKey) defined and implemented in Java.
A Breadth-First Search (BFS) Planner capable of generating action sequences implemented and tested via simulation.
An ExecutionEngine capable of processing plans and handling action results (SUCCESS, FAILURE, IN_PROGRESS) implemented and tested via simulation.
A DreamBotWorldObserver implemented to read live game state (VarPlayers, Areas, Inventory, Skills, UI, Objects, etc.) using the DreamBot API and update the WorldState. This includes detailed mapping for Tutorial Island based on external research and specific VarPlayer (281) tracking.
A comprehensive set of concrete Action classes implemented, covering most interactions required for Tutorial Island (talking, walking, object/item interaction, skilling, UI manipulation, basic combat/magic).
The main script (TutorialIslandGOAPScript) structured to orchestrate the Observe -> Determine Goal -> Plan -> Execute cycle.
Goal determination logic (determineCurrentGoal) and action loading (loadAvailableActions) structurally completed for the entire Tutorial Island sequence.
Current Status: The project has completed the initial implementation phases (1-4). The core GOAP engine is built and tested in simulation. The observer is integrated with the DreamBot API and refined based on initial testing and research. All necessary Action types have been implemented, and the main script logic for goal sequencing and action loading is in place. However, the script has not yet undergone full end-to-end testing. Many parameters within the loadAvailableActions method (Object IDs, Tile coordinates, Animation IDs, Widget Paths) and potentially some goal conditions in determineCurrentGoal require in-game verification and correction.
Next Immediate Step: Phase 4.5/4.6 - Comprehensive in-game testing, verification of all placeholders, and debugging of the full Tutorial Island sequence.
2. Architecture Overview
The system employs a Goal-Oriented Action Planning (GOAP) architecture:
World State (WorldState / WorldStateKey): A central Map representing the agent's knowledge of the game, using a type-safe WorldStateKey enum with prefixed names for organization.
Observer (DreamBotWorldObserver): Runs each game loop (onLoop) to update the WorldState by querying the DreamBot API. Uses researched VarPlayer values and Area definitions for Tutorial Island context.
Goal (Goal): Defines the desired end state for a specific task or tutorial section (e.g., S1_HAS_LOGS = true). Goals are determined sequentially based on the current TUT_STAGE_ID in the WorldState.
Actions (Action interface & implementations): Represent discrete, executable tasks (e.g., ActionCutTree, ActionTalkToNPC). Each action defines:
Preconditions: Conditions in WorldState required for the action to be planned/executed.
Effects: Anticipated changes to WorldState upon successful completion (used by planner).
Cost: A numeric value representing the effort/time (used by planner).
isApplicable(): Runtime check if the action can run now.
perform(): Contains DreamBot API calls to execute the action, returning SUCCESS, FAILURE, or IN_PROGRESS.
Planner (Planner): Uses a Breadth-First Search (BFS) algorithm (for MVP) to find the lowest-cost sequence of applicable actions (Plan) to transition the WorldState from its current state to satisfy the currentGoal. Uses WorldState.equals/hashCode and a closed set for cycle detection.
Plan (Plan): A simple wrapper around a Queue<Action> holding the sequence generated by the planner.
Execution Engine (ExecutionEngine): Takes the Plan, executes one action's perform() method per loop cycle, handles the ActionResult, manages IN_PROGRESS states (by retrying the same action), and signals REPLAN_NEEDED on FAILURE.
Main Script (TutorialIslandGOAPScript): Orchestrates the cycle: Observe -> Determine Goal -> Plan (if needed) -> Execute.
3. Codebase Structure
Core.GOAP: Contains the core, game-independent GOAP components (Action, ActionResult, Goal, Plan, Planner, WorldState, WorldStateKey).
Core.GOAP.Mock: Contains mock Action implementations and the GoapSimulator used for testing the core engine in isolation (Phases 1 & 2).
Core.GameIntegration: Contains classes bridging GOAP and DreamBot (DreamBotWorldObserver).
Core.Actions: Contains concrete implementations of the Action interface using DreamBot API calls (e.g., ActionWalkToTile, ActionCutTree, ActionTalkToNPC).
Main: Contains the main script entry point (TutorialIslandGOAPScript).
Utils: Contains utility classes reused from the previous AIO project (functionality assumed, not detailed here).
4. Key Components Documentation
(Refer to previous phase documentation files for more granular detail on each component's methods and initial implementation)
WorldStateKey (Enum): Defines all known state variables using a prefixed naming convention (e.g., TUT_STAGE_ID, LOC_CURRENT_AREA_NAME, INV_SPACE, S1_HAS_LOGS).
WorldState (Class): Map-based state storage with typed accessors, satisfies() check, applyEffects(), and crucial copy(), equals(), hashCode() methods.
Goal (Class): Holds a name and target conditions (Map<WorldStateKey, Object>), provides isSatisfied().
ActionResult (Enum): SUCCESS, FAILURE, IN_PROGRESS.
Action (Interface): Contract defining getName, getPreconditions, getEffects, getCost, isApplicable, perform. Includes optional lifecycle hooks.
Planner (Class): Implements BFS search to generate a Plan. Handles state expansion, cycle detection (via closedSet and WorldState.equals/hashCode), and goal checking.
Plan (Class): Wrapper for Queue<Action>.
ExecutionEngine (Class): Manages execution of Plan, calls Action.perform, handles ActionResult, signals REPLAN_NEEDED. Defines EngineStatus enum.
DreamBotWorldObserver (Class): Uses DreamBot API (PlayerSettings, Inventory, GameObjects, NPCs, Players, Tabs, Widgets, Dialogues, Skills, Equipment, Bank, Prayers) to update WorldState based on researched Tutorial Island data (VarP 281 mapping, Areas, Object IDs, Widget IDs). Contains placeholders requiring verification.
Core.Actions.* (Classes): Concrete action implementations using DreamBot API calls corresponding to tutorial tasks. Contain internal state management for IN_PROGRESS results (e.g., animation timers). Rely on verified parameters.
TutorialIslandGOAPScript (Class): Main script extending AbstractScript. Initializes components, contains the main Observe-DetermineGoal-Plan-Execute loop, manages goal progression based on TUT_STAGE_ID, and loads all Action instances. Contains incomplete goal definitions and action instantiations pending verification.
5. Setup / Dependencies
Java Version: Developed and tested targeting Java 8 compatibility (due to DreamBot client constraints and observed API method availability).
DreamBot Client: Requires a standard DreamBot 3 client installation.
DreamBot API: Code relies on the DreamBot 3 API library (assumed to be included as a dependency, e.g., client.jar).
Utils Package: Assumes the presence of the Utils package copied from the previous AIO project.
6. Testing Strategy
Phases 1 & 2: Core engine logic (Planner, Executor) tested via GoapSimulator using mock actions in a plain Java environment.
Phase 3: DreamBotWorldObserver tested iteratively in-game by running a minimal script that logs WorldState values while the user manually performs actions. Research reports were used to refine observer logic.
Phase 4 (Current): Requires end-to-end in-game testing. The user (B_Arnie) will run the TutorialIslandGOAPScript on a fresh account. They will manually follow the script's intended actions, verifying and correcting all placeholder data (Object IDs, Tiles, Animation IDs, Area Coords, Widget Paths) within loadAvailableActions and DreamBotWorldObserver as each step is encountered. They will also verify the determineCurrentGoal logic and the conditions within createGoal... methods trigger correctly. Issues and required corrections will be communicated back for implementation.
7. Future Work (Optional - Post-MVP)
Observer/Action Parameter Verification: Complete the manual verification process outlined in the Testing Strategy.
Refinement: Refine dialogue detection, VarP trigger points, goal conditions, and action logic based on testing. Refactor ActionCastSpellOnNPC rune checks.
WorldStateKey Refactoring: Split the single enum into context-specific enums.
Username-Hash Based Profiles: Implement profile generation based on username hash to influence planner weights/costs for behavioral variation.
Advanced Anti-Ban: Implement passive behaviors (Layer A) and decoy goals (Layer B).
Error Handling/Recovery: Implement more robust strategies for handling persistent action failures or unexpected game states beyond simple replanning.
Logging: Implement SimpleLogger (Phase 6.1/6.2) for structured console and file logging.
Expand Content: Add planners and actions for other skills, quests, combat scenarios.
Monitoring Hub: Develop the local web dashboard concept.
8. Notes for New AI Agent
Current Position: You are joining at the completion of Phase 4 implementation. The core GOAP framework is built, the observer is connected to the game, and all necessary actions for Tutorial Island have been structurally implemented and added to the main script.
Immediate Task: The critical next step is Phase 4.5/4.6: Testing and Verification. Your role will be to support the user (B_Arnie) during this phase. They will run the script and provide feedback on errors, incorrect parameters, or flawed logic. You will be responsible for implementing the necessary corrections in the codebase (primarily loadAvailableActions, determineCurrentGoal, createGoal... methods, and potentially refining Action or DreamBotWorldObserver logic based on their findings).
Workflow: Expect prompts from the co-project lead (me, the previous AI) or the user (B_Arnie) detailing specific issues found during testing and requesting code modifications.
Key Resources: Utilize this README.md, the previously generated phase documentation files, the existing codebase, and the provided dreambot_javadocs_compiled.pdf for API reference.
Collaboration: Ask clarifying questions if the user's feedback or the required changes are unclear. Adhere to the established architecture and coding patterns.
