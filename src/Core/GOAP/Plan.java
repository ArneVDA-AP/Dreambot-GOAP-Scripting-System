package Core.GOAP; // Or your preferred package structure

import java.util.LinkedList;
import java.util.Queue;
import java.util.stream.Collectors;

/**
 * Represents a sequence of Actions generated by the Planner to achieve a Goal.
 * Internally uses a Queue to maintain the order of execution.
 */
public class Plan {

    private final Queue<Action> actionQueue;

    /**
     * Constructs a Plan with a given queue of actions.
     * The provided queue should contain actions in the order they are to be executed.
     *
     * @param actions A Queue containing the sequence of Actions for this plan.
     */
    public Plan(Queue<Action> actions) {
        // It's generally safer to create a new queue from the provided one,
        // in case the original queue is modified elsewhere.
        this.actionQueue = (actions != null) ? new LinkedList<>(actions) : new LinkedList<>();
    }

    /**
     * Checks if the plan contains any actions.
     *
     * @return true if the plan is empty, false otherwise.
     */
    public boolean isEmpty() {
        return actionQueue.isEmpty();
    }

    /**
     * Retrieves and removes the next action from the front of the plan queue.
     * Returns null if the plan is empty.
     *
     * @return The next Action to be executed, or null if the plan is complete.
     */
    public Action getNextAction() {
        return actionQueue.poll(); // poll() returns null if queue is empty
    }

    /**
     * Retrieves the next action from the front of the plan queue without removing it.
     * Returns null if the plan is empty.
     * Useful for inspecting the next step without advancing the plan.
     *
     * @return The next Action to be executed, or null if the plan is complete.
     */
    public Action peekNextAction() {
        return actionQueue.peek(); // peek() returns null if queue is empty
    }

    /**
     * Returns the number of actions remaining in the plan.
     *
     * @return The count of remaining actions.
     */
    public int size() {
        return actionQueue.size();
    }

    /**
     * Clears all actions from the plan.
     * Useful when replanning is required.
     */
    public void clear() {
        actionQueue.clear();
    }

    /**
     * Provides a string representation of the plan, listing the action names.
     *
     * @return A string describing the plan sequence.
     */
    @Override
    public String toString() {
        if (isEmpty()) {
            return "Plan{Empty}";
        }
        String sequence = actionQueue.stream()
                .map(Action::getName) // Assumes Action interface has getName()
                .collect(Collectors.joining(" -> "));
        return "Plan{" + sequence + "}";
    }
}
