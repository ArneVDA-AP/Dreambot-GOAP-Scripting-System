package Core.GOAP; // Should be in Core.GOAP, not Core.GOAP.Mock

import Core.GOAP.Action;
import Core.GOAP.ActionResult;
import Core.GOAP.Plan;
import Core.GOAP.WorldState;

import java.util.LinkedList;
import java.util.Objects;

/**
 * Manages the execution of a Plan generated by the GOAP Planner.
 * It processes one action at a time based on the plan queue and handles
 * the results (SUCCESS, FAILURE, IN_PROGRESS) returned by the actions.
 */
public class ExecutionEngine {

    /**
     * Represents the status of the Execution Engine after attempting a step.
     */
    public enum EngineStatus {
        /** The engine is actively executing an action (could be IN_PROGRESS or just finished one successfully). */
        EXECUTING,
        /** The engine has no plan or the current plan is empty. */
        IDLE,
        /** The current plan was successfully completed. */
        PLAN_COMPLETE,
        /** The last action failed, and a replan is required. */
        REPLAN_NEEDED
    }

    private Plan currentPlan;
    private Action currentAction; // The action currently being executed (might span multiple ticks)

    public ExecutionEngine() {
        // Initialize with an empty plan to avoid null checks later
        this.currentPlan = new Plan(new LinkedList<>());
        this.currentAction = null;
    }

    /**
     * Sets the plan for the engine to execute. If there's an existing plan,
     * it will be replaced. Any currently executing action will be aborted.
     *
     * @param plan The new Plan to execute. Can be null or empty.
     */
    public void setPlan(Plan plan) {
        if (this.currentAction != null) {
            // If an action was in progress, notify it that it's being aborted
            System.out.println("ENGINE: Aborting action: " + currentAction.getName()); // Logging
            this.currentAction.onAbort();
            this.currentAction = null;
        }
        // Ensure plan is never null, use an empty plan if null is passed (Java 8 compatible)
        this.currentPlan = (plan != null) ? plan : new Plan(new LinkedList<>());
        System.out.println("ENGINE: New plan set. Plan: " + this.currentPlan); // Logging
    }

    /**
     * Checks if the engine currently has a non-empty plan or an action in progress.
     * @return true if executing or has actions queued, false if idle.
     */
    public boolean isExecuting() {
        // Engine is considered executing if it has a current action or if the plan queue is not empty
        return currentAction != null || (currentPlan != null && !currentPlan.isEmpty());
    }

    /**
     * Gets the name of the action currently being executed.
     * @return The name of the current action, or "Idle" if no action is running.
     */
    public String getCurrentActionName() {
        return (currentAction != null) ? currentAction.getName() : "Idle";
    }


    /**
     * Executes the next step in the current plan based on the provided WorldState.
     * This method should be called repeatedly (e.g., in the main script loop).
     *
     * @param currentState The current WorldState provided by the WorldObserver.
     * @return EngineStatus indicating the outcome of the step.
     */
    public EngineStatus executeNextStep(WorldState currentState) {
        // If no action is currently being processed, try to get the next one from the plan
        if (currentAction == null) {
            // Check if the plan object itself is null OR if the queue inside is empty
            if (currentPlan == null || currentPlan.isEmpty()) {
                // System.out.println("ENGINE: Plan is empty or null. Engine Idle."); // Logging
                return EngineStatus.IDLE; // Nothing to do
            }
            currentAction = currentPlan.getNextAction(); // Dequeue the next action

            if (currentAction == null) {
                // This case means the plan queue was empty after the check, indicating completion.
                System.out.println("ENGINE: Plan queue is now empty. Plan Complete."); // Logging
                return EngineStatus.PLAN_COMPLETE;
            }
            System.out.println("ENGINE: Starting action: " + currentAction.getName()); // Logging
            currentAction.onStart(); // Call the optional onStart hook
        }

        // --- Execute the current action ---
        // Ensure currentAction is not null before calling perform (safety check)
        if (currentAction == null) {
            System.err.println("ENGINE: Error - currentAction became null unexpectedly.");
            currentPlan.clear(); // Clear plan as state is inconsistent
            return EngineStatus.REPLAN_NEEDED;
        }

        System.out.println("ENGINE: Performing action: " + currentAction.getName()); // Logging
        ActionResult result = currentAction.perform(currentState);
        System.out.println("ENGINE: Action '" + currentAction.getName() + "' result: " + result); // Logging

        // --- Process the result ---
        switch (result) {
            case SUCCESS:
                currentAction.onSuccess(); // Call optional hook
                Action completedAction = currentAction; // Store for logging/checking
                currentAction = null; // Clear current action, ready for the next one
                // Check again if the plan is now empty after completing this action
                if (currentPlan.isEmpty()) {
                    System.out.println("ENGINE: Action '" + completedAction.getName() + "' succeeded. Plan Complete."); // Logging
                    return EngineStatus.PLAN_COMPLETE;
                } else {
                    System.out.println("ENGINE: Action '" + completedAction.getName() + "' succeeded. Proceeding to next action."); // Logging
                    return EngineStatus.EXECUTING; // More actions in the plan
                }

            case FAILURE:
                currentAction.onFailure(); // Call optional hook
                String failedActionName = currentAction.getName(); // Store name before clearing
                currentAction = null; // Clear the failed action
                currentPlan.clear(); // Clear the rest of the plan as it's now invalid
                System.err.println("ENGINE: Action '" + failedActionName + "' failed. Replanning needed."); // Logging
                return EngineStatus.REPLAN_NEEDED; // Signal main loop to replan

            case IN_PROGRESS:
                System.out.println("ENGINE: Action '" + currentAction.getName() + "' is IN_PROGRESS."); // Logging
                // Do nothing to currentAction or currentPlan.
                // The same action will be executed again in the next call to executeNextStep.
                return EngineStatus.EXECUTING; // Still working

            default:
                // Should not happen if ActionResult enum is used correctly
                String unknownActionName = (currentAction != null) ? currentAction.getName() : "Unknown";
                System.err.println("ENGINE: Unknown ActionResult received from action: " + unknownActionName); // Logging
                if(currentAction != null) currentAction.onFailure(); // Treat as failure
                currentAction = null;
                currentPlan.clear();
                return EngineStatus.REPLAN_NEEDED;
        }
    }
}